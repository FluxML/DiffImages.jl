var documenterSearchIndex = {"docs":
[{"location":"colors/","page":"Colorspace Transforms","title":"Colorspace Transforms","text":"CurrentModule = DiffImages","category":"page"},{"location":"colors/#Colorspace-Transforms","page":"Colorspace Transforms","title":"Colorspace Transforms","text":"","category":"section"},{"location":"colors/","page":"Colorspace Transforms","title":"Colorspace Transforms","text":"note: Consistency with the batch dimension\nSince we require the last dimension to be the batch dimension,  kindly unsqueeze the last dimension if you would like to pass a single image.","category":"page"},{"location":"colors/","page":"Colorspace Transforms","title":"Colorspace Transforms","text":"Modules = [DiffImages]\nPages = [\"colors/conversions.jl\"]","category":"page"},{"location":"colors/#DiffImages.channelify-Union{Tuple{AbstractArray{CT, N}}, Tuple{N}, Tuple{CT}} where {CT<:ColorTypes.Colorant, N}","page":"Colorspace Transforms","title":"DiffImages.channelify","text":"channelify(m::AbstractArray{CT,N}) where {CT <: Colorant, N}\n\nChannelify function.\n\nInput should be in WHN order implies (* batch). Output will be in the order (* channels batch).\n\nExamples\n\njulia> input_size = (16, 16, 2)\n(16, 16, 2)\n\njulia> size(channelify(HSV.(rand(BGR,input_size...))))\n(16, 16, 3, 2)\n\n\n\n\n\n","category":"method"},{"location":"colors/#DiffImages.colorify-Union{Tuple{CT}, Tuple{Type{CT}, AbstractArray}} where CT<:ColorTypes.Colorant","page":"Colorspace Transforms","title":"DiffImages.colorify","text":"colorify(color::Type{CT}, m::AbstractArray) where CT <: Colorant\n\nColorify function.\n\nExpecting an input of the type (* channels batch). Converts the array to the color specified.\n\nExamples\n\njulia> input_size = (25, 25, 3, 7)\n(25, 25, 3, 7)\n\njulia> size(colorify(HSV, rand(input_size...)))\n(25, 25, 7)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/homog/warp/#Tutorials","page":"Homography warps","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/homog/warp/#Homography-warps","page":"Homography warps","title":"Homography warps","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Pages = [\"warp.md\"]\nDepth = 5","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Homography matrices are projective transformations. They can be represented using DiffImages.Homography() in Julia using DiffImages.","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"In this example, we will train a homography matrix using DiffImages.jl.","category":"page"},{"location":"tutorials/homog/warp/#Importing-the-libraries","page":"Homography warps","title":"Importing the libraries","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"using Pkg\nPkg.add([\"ImageTransformations\", \"ImageCore\", \"Zygote\", \"FileIO\", \"ImageMagick\"])","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"using DiffImages, ImageCore, ImageTransformations, FileIO, Zygote","category":"page"},{"location":"tutorials/homog/warp/#Loading-the-images","page":"Homography warps","title":"Loading the images","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Let us load the images first. We will also convert them to Float32 precision type since we do not need such high precision.","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"img = load(\"source.jpg\") .|> RGB{Float32}\ntgt = load(\"target.jpg\") .|> RGB{Float32}","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Source Image Destination Image\n(Image: src) (Image: tgt)","category":"page"},{"location":"tutorials/homog/warp/#Initializing-the-matrix-and-hyperparameters","page":"Homography warps","title":"Initializing the matrix and hyperparameters","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Now let us define the homography matrix and other parameters such as the learning rate.","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"h = DiffImages.Homography{Float32}()\nη = 2e-11 # Varies a lot example to example\nnum_iters = 100","category":"page"},{"location":"tutorials/homog/warp/#Defining-the-criterion","page":"Homography warps","title":"Defining the criterion","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Nice! Now before we jump to the training loop, let us first define an Images-centric version of the mean squared error loss as our criterion.","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"function image_mse(y, ŷ)\n    l = map((x, y) -> (x - y), y, ŷ)\n    l = mapreducec.(x->x^2, +, 0, l)\n    l = sum(l)\n    l\nend","category":"page"},{"location":"tutorials/homog/warp/#Defining-the-training-loop","page":"Homography warps","title":"Defining the training loop","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Great! Now that we have defined our criterion, let us now define the training loop.","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"for i in 1:num_iters\n    ∇H, = Zygote.gradient(h) do trfm\n            out = ImageTransformations.warp(img, trfm, axes(img), zero(eltype(img)))\n            out = image_mse(out, tgt)\n            out\n        end\n\n    out = ImageTransformations.warp(img, h, axes(img), zero(eltype(img)))\n    println(\"Iteration: $i Loss: $(image_mse(out, tgt))\")\n\n    h = h.H - η * (∇H.H)\n    h = DiffImages.Homography(h |> SMatrix{3, 3, Float32, 9})\nend","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Iteration: 1 Loss: 7519.01\nIteration: 2 Loss: 8512.313\nIteration: 3 Loss: 8508.674\nIteration: 4 Loss: 8503.572\nIteration: 5 Loss: 8494.75\nIteration: 6 Loss: 8463.264\nIteration: 7 Loss: 8371.489\nIteration: 8 Loss: 8107.0605\nIteration: 9 Loss: 7883.7715\nIteration: 10 Loss: 7920.1157\nIteration: 11 Loss: 7897.9946\nIteration: 12 Loss: 7637.454\nIteration: 13 Loss: 7465.2075\nIteration: 14 Loss: 7369.2275\nIteration: 15 Loss: 7361.462\n...\nIteration: 90 Loss: 7450.904\nIteration: 91 Loss: 7260.4014\nIteration: 92 Loss: 7292.6904\nIteration: 93 Loss: 7172.2715\nIteration: 94 Loss: 7313.829\nIteration: 95 Loss: 7288.0854\nIteration: 96 Loss: 7205.045\nIteration: 97 Loss: 7223.6016\nIteration: 98 Loss: 7304.29\nIteration: 99 Loss: 7179.936\nIteration: 100 Loss: 7162.128","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"Here, ∇H is the gradient of the matrix with respect to the scalar output. It can be represented mathematically to be -","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"H = \nbeginbmatrix\nfracpartialLpartialH_ij\nendbmatrix","category":"page"},{"location":"tutorials/homog/warp/#Results","page":"Homography warps","title":"Results","text":"","category":"section"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"After training your matrix successfully, you shall get something like this.","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"η = 1e-10 η = 2e-10\n(Image: homo-gif) (Image: homo-gif2)","category":"page"},{"location":"tutorials/homog/warp/","page":"Homography warps","title":"Homography warps","text":"It is apparently difficult to train a homography matrix. Therefore, finding the right hyperparameters is the key to training it correctly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DiffImages","category":"page"},{"location":"#DiffImages.jl","page":"Home","title":"DiffImages.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI status) (Image: Docs-Dev) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiffImages.jl is a Computer Vision library, which aims to make relavant parts of the JuliaImages ecosystem differentiable. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have started with making parts of Images.jl and ImageTransformations.jl differentiable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we provide support to the following modules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warping modules inside of ImageTransformations.jl.\nwhich includes ImageTransformations.warp, with support for transformations from CoordinateTransformations.jl.\nColorspace modules from ImageCore.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the future, we aim to extend support to kernels from ImageFiltering.jl as well as extend support to image derivatives which are not currently possible due to no implementations for different types of interpolants used in Interpolations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Have a look at the tutorials given below to see what you an do using this package :)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"tutorials/homog/warp.md\", \"tutorials/rotate/rotate.md\"]\nDepth = 2","category":"page"},{"location":"geometry/warp/","page":"Warp Modules","title":"Warp Modules","text":"CurrentModule = DiffImages","category":"page"},{"location":"geometry/warp/#Geometric-modules","page":"Warp Modules","title":"Geometric modules","text":"","category":"section"},{"location":"geometry/warp/#Warp-modules","page":"Warp Modules","title":"Warp modules","text":"","category":"section"},{"location":"geometry/warp/","page":"Warp Modules","title":"Warp Modules","text":"Modules = [DiffImages]\nPages = [\"geometry/warp.jl\"]","category":"page"},{"location":"geometry/warp/#DiffImages.Homography","page":"Warp Modules","title":"DiffImages.Homography","text":"Homography{T} <: CoordinateTransformations.Transformation\n\nWrapper enclosing a Homography matrix, internally represented as a SMatrix from StaticArrays. Supports all the features that a CoordinateTransformations.Transformation supports. Outputs homogenous coordinates.\n\nExamples\n\njulia> h = DiffImages.Homography()\nDiffImages.Homography{Float64} with:\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> h(SVector((1.0, 2.0, 3.0)))\n2-element SVector{2, Float64} with indices SOneTo(2):\n 0.3333333333333333\n 0.6666666666666666\n\n\n\n\n\n","category":"type"},{"location":"tutorials/rotate/rotate/#Rotation-transforms","page":"Rotation transforms","title":"Rotation transforms","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Pages = [\"rotate.md\"]\nDepth = 5","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Rotation transforms are pretty straightforward - they rotate the image about a certain point through a certain angle θ. In this tutorial, I will train a Rotation matrix.","category":"page"},{"location":"tutorials/rotate/rotate/#Importing-the-required-libraries","page":"Rotation transforms","title":"Importing the required libraries","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Let us first import the required libraries.","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"using Pkg\nPkg.add([\"ImageTransformations\", \"ImageCore\", \"Zygote\", \"CoordinateTransformations\", \"FileIO\", \"ImageMagick\"])","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"using DiffImages, ImageTransformations, CoordinateTransformations, ImageCore, FileIO, StaticArrays","category":"page"},{"location":"tutorials/rotate/rotate/#Loading-the-image","page":"Rotation transforms","title":"Loading the image","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"For this tutorial, we shall use the Julia Dots logo.","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"img = load(\"julia_dots.png\") .|> RGB{Float32}\nimg = imresize(img, ratio = 1/3)","category":"page"},{"location":"tutorials/rotate/rotate/#Initializing-the-transform","page":"Rotation transforms","title":"Initializing the transform","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"We shall rotate the image from the origin at an arbitrary angle θ. Let us create a function which initializes the matrix to a LinearMap.","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"beginbmatrix\ncostheta  sintheta\n-sintheta  costheta\nendbmatrix","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"m(θ) = LinearMap(SMatrix{2, 2, Float32, 4}([cos(θ) -sin(θ); sin(θ) cos(θ)]))","category":"page"},{"location":"tutorials/rotate/rotate/#Setting-the-target-image","page":"Rotation transforms","title":"Setting the target image","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Let us set our target image to angle of π/6. ","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"tgt = ImageTransformations.warp(img, m(π/6), axes(img), zero(eltype(img)))","category":"page"},{"location":"tutorials/rotate/rotate/#Setting-the-hyperparameters","page":"Rotation transforms","title":"Setting the hyperparameters","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Let us initialize the hyperparameters - the learning rate η, the total number of iterations num_iters we should train for, and the initial angle θ from where we should start training.","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"η = 1e-6\nnum_iters = 100\nθ = 0.05 # Starting from zero will get you stuck in a local minima, so start a bit off.","category":"page"},{"location":"tutorials/rotate/rotate/#Defining-the-criterion","page":"Rotation transforms","title":"Defining the criterion","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Great! Now before we jump to the training loop, let us first define an Images-centric version of the mean squared error loss as our criterion.","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"function image_mse(y, ŷ)\n    l = map((x, y) -> (x - y), y, ŷ)\n    l = mapreducec.(x->x^2, +, 0, l)\n    l = sum(l)\n    l\nend","category":"page"},{"location":"tutorials/rotate/rotate/#Training-loop","page":"Rotation transforms","title":"Training loop","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Now that we are ready, let's get to train our matrix. Here we only have a single scalar parameter θ for training.","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"for i in 1:num_iters\n    ∇θ, = Zygote.gradient(θ) do θ\n            out = ImageTransformations.warp(img, m(θ), axes(img), zero(eltype(img)))\n            out = image_mse(out, tgt)\n            out\n        end\n\n    out = ImageTransformations.warp(img, m(θ), axes(img), zero(eltype(img)))\n    println(\"Iteration: $i Loss: $(image_mse(out, tgt))\")\n\n    θ = θ + η*∇θ\nend","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"Iteration: 1 Loss: 5878.8823\nIteration: 2 Loss: 5721.9014\nIteration: 3 Loss: 5499.8564\nIteration: 4 Loss: 5248.2817\nIteration: 5 Loss: 5001.5283\nIteration: 6 Loss: 4771.129\nIteration: 7 Loss: 4549.8735\nIteration: 8 Loss: 4342.372\nIteration: 9 Loss: 4145.0225\nIteration: 10 Loss: 3958.0752\nIteration: 11 Loss: 3778.5156\nIteration: 12 Loss: 3604.375\nIteration: 13 Loss: 3432.296\nIteration: 14 Loss: 3262.7085\nIteration: 15 Loss: 3099.788\n...\nIteration: 90 Loss: 648.5401\nIteration: 91 Loss: 644.355\nIteration: 92 Loss: 640.3202\nIteration: 93 Loss: 636.3374\nIteration: 94 Loss: 632.3824\nIteration: 95 Loss: 628.35864\nIteration: 96 Loss: 623.8506\nIteration: 97 Loss: 619.3939\nIteration: 98 Loss: 615.4604\nIteration: 99 Loss: 611.1207\nIteration: 100 Loss: 606.791","category":"page"},{"location":"tutorials/rotate/rotate/#Results","page":"Rotation transforms","title":"Results","text":"","category":"section"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"A finely trained model will train the image like this -","category":"page"},{"location":"tutorials/rotate/rotate/","page":"Rotation transforms","title":"Rotation transforms","text":"θ = π/6 θ = π/12\n(Image: π/6) (Image: π/12)","category":"page"}]
}
